---
title: 节流和防抖
date: 2021-11-30
tags:
- js
---
#### 函数防抖(debounce)
函数防抖(debounce)：触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间。
<!--more-->
实现原理：定义一个计时器，在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。
```
function debounce(fn,delay) {
    var timeout = null; 
    return function (e) {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
            fn.apply(this, arguments);
        }, delay);
    };
}
```

#### 函数节流(throttle)

函数节流(throttle)：高频事件触发，但在n秒内只会执行一次。
实现原理：一定时间内只触发一次函数。原理是通过判断是否有延迟调用函数未执行，如果当前有等待执行的延时函数，则直接return
```
function throttle(fn,delay) {
    let canRun = true; 
    return function () {
        if (!canRun) return;
        canRun = false;
        setTimeout(() => {
            fn.apply(this, arguments);
            canRun = true;
        }, delay);
    };
```

函数节流（throttle）与 函数防抖（debounce）都是为了限制函数的执行频次，以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。
区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。