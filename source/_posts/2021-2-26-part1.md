---
title: Vue2与Vue3区别
date: 2021-2-26
tags:
- vue
- vue2
- vue3
---


#### 一、原理
Vue2 的双向数据绑定是利用ES5 的 API  Object.definePropert() 对数据进行劫持结合发布订阅模式的方式来实现的。
Vue3 则是使用了 es6 的 proxy API 对数据代理。
<!--more-->
proxy的优势:
1. 能对全对象监听
2. 可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）
3. 可以监听数组，可以检测到数组内部数据的变化


#### 二、Vue3组件可以拥有多个根节点
Vue2
![图片描述](/img/part-1/1.png)

Vue3
![图片描述](/img/part-1/2.png)

#### 三. Composition API
 
1、Vue2使用选项类型API（Options API）,Vue3则是合成型API（Composition API）
2、Vue2 API在代码里分割了不同的属性: data,computed属性，methods，等等。Vue3 API能让我们用方法（function）来分割，相比于Vue2代码会更加简便和整洁。
3、Vue2把数据放入data属性中,Vue3.使用一个新的setup()方法,在vue引入reactive，使用reactive()方法来声名响应性数据
4、Vue3 在setup内注册生命周期钩子

Vue2
![图片描述](/img/part-1/3.png)

Vue3
![图片描述](/img/part-1/4.png)

#### 四、Vue3生命周期
 
setup() : 开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method
onBeforeMount() : 组件挂载到节点上之前执行的函数。
onMounted() : 组件挂载完成后执行的函数。
onBeforeUpdate(): 组件更新之前执行的函数。
onUpdated(): 组件更新完成之后执行的函数。
onBeforeUnmount(): 组件卸载之前执行的函数。
onUnmounted(): 组件卸载完成后执行的函数

#### 五、父子传参不同，setup() 函数特性
 
1、setup 函数接受两个参数：（props、context(attrs、slots、emit)）
2、setup函数中不能使用this
3、setup 函数中的 props 是响应式的，当传入新的 prop 时，会被更新。但是， props 是响应式的，你不能使用 ES6 解构（从数组或对象中提取值,对变量进行赋值），因为它会消除 prop 的响应性，如果需要解构 prop，可以通过使用 setup 函数中的toRefs 来完成此操作：

父传子，props
![图片描述](/img/part-1/5.png)

子传父，事件
![图片描述](/img/part-1/6.png)

#### 六、Vue3两种构建响应式数据的方式
reactive
1. reactive方法，直接传入一个对象 state ,这个对象就是 proxy 拦截的对象
2. 然后再把这个 state 对象直接 return 出去就能被调用
3. 在 temolate 中使用 state.msg 来访问
4. 在 js 中也使用 state.msg 来访问
ref
1.使用 ref 直接声明一个 proxy 响应式对象 msg
2.然后把这个 msg 对象直接 return 出去
3.在 template 中直接使用 {{msg.value}}
4.注意：在 js 中需要使用 msg.value