---
title: flv.js直播拉流下的技术优化
date: 2021-12-6
tags:
- js
---

#### 一、flv.js
flv.js: https://github.com/Bilibili/flv.js

<!--more-->

chrome已不支持flash的更新维护，2020年12月在Chrome 87中彻底移除，HTML5原生支持播放mp4/webm格式，flv.js实现了在HTML5上播放FLV格式视频，支持延迟极低http flv播放，极低的运行开销，延迟是能控制在1~3m秒内的，且支持所有主流的浏览器（Chrome、FireFox、IE11、Edge、safari等）

原理：
flv.js在获取到FLV格式的音视频数据后将 FLV 文件流转码复用成 ISO BMFF（MP4 碎片）片段，再通过Media Source Extensions API 传递给原生HTML5 Video标签进行播放。

flv.js 是使用 Es6 编写的，然后通过 Babel Compiler 编译成 Es5，使用 Browserify 打包。

#### 二、直播卡顿和减少延时性方案

##### 1、延时大，并且会随着播放时间累积放大
拉流延迟基本处于5~10s不稳定，对于flv还是比较大的，且暂停播放直播流再恢复，会发现延时会累积或者在长时间播放直播流，会发现延时也会变得越来越大

①、针对缓存过大的问题，延迟性过大的问题
属性autoCleanupSourceBuffer设置为true，对SourceBuffer进行自动清理
属性enableStashBuffer默认为true,即启用IO隐藏缓冲区，如果网络抖动，可能会停顿，针对直播（最小延迟）来进行实时流播放，设置为false
属性stashInitialSize指示IO暂存缓冲区的初始大小，通过测试设置值为2048，可达到改善视频相应的负载.
属性enableDurationMonitor设置为true，当发现直播流延迟过大时，主动去追赶。
属性decreaseDurationStep设置为2，每次追赶至缓冲区末尾之前的2秒

实现的效果是延迟控制在1~3秒内，并且如果画面延迟过高会主动进行画面的追赶
![图片描述](/img/part-7/1.png)


##### 2、Chrome Console中经常有各种报错


遇到的报错有：
```
Failed to read the ‘buffered’ property from ‘SourceBuffer’: This SourceBuffer has been removed from the parent media source
```

无法从“SourceBuffer”读取“buffered”属性
错误提示一般是在flv源发生异常中断的时候产生的，
大致是在执行![图片描述](/img/part-7/2.png)这些方法触发的异常，解决思路是修改flv.js源码，在这几个触发的方法下面
![图片描述](/img/part-7/3.png)调用，而加上checkMediaSource后，就忽略了已经失效的mediasource


##### 3、拉流过程中浏览器内存占用太大
降低 autoCleanupMaxBackwardDuration 和 autoCleanupMinBackwardDuration 这两个值，减少MSE缓存大小，它们的默认值分别是180秒和120秒，测试后调整为各100,同时存在切换页面tab一段时间在回到页面的时候内容占用也会增大，处理机制监测页面切换tab 5分钟销毁H5播放器，暂停推流，减少资源消耗，重新切换回来时重新构建H5播放器，并且重新拉流

##### 4、直播视频画面卡停、黑屏
产生原因大致为播放源出现问题、或者网络不稳定出现了问题监听flv.js的一些事件，NetworkError和MediaError，当监听到报错进行重新初始化并且再次拉流同时增加一个自定义事件VIDEO_FROZEN，通过检测statistic_info的decode_frames数值,也就是帧率没有在变化的时候，判断视频已经卡停，进行重新拉流

##### 5、画面卡顿监测降低清晰度
由于本地网络不好导致可能出现有些人观看直播卡顿严重,处理方案是当观看卡顿时，降低视频码率，也就是自动降低清晰度，判断依据是每1秒掉4帧自动切换更低清晰度的流，通过修改statistics_info的上报时间，计算每秒内前后帧率的差值如果大于4帧，就重新拉流，并降低清晰度


